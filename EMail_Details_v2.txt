# Email analysis for "inbox_copy" on a date:
# - Total count + hourly breakdown
# - Details (From/To), sorted by time
# - "To-only" view for a chosen address (no Cc/Bcc)
# - Ack check: did we send ANY email to the inbound sender later the same day? (To-only, no Cc/Bcc)
# - Final Totals: Total emails, Total with 'me' in To (any + To-only), Acknowledged, Original vs Replies
# Permissions: Azure AD app with Microsoft Graph Mail.Read (application) is sufficient (read-only).

try { [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 } catch {}

function Get-AccessToken {
    param(
        [Parameter(Mandatory=$true)] [string]$TenantId,
        [Parameter(Mandatory=$true)] [string]$ClientId,
        [Parameter(Mandatory=$true)] [securestring]$ClientSecret
    )
    $tokenUrl = "https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token"
    $secretPtr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($ClientSecret)
    try {
        $secretPlain = [Runtime.InteropServices.Marshal]::PtrToStringAuto($secretPtr)
        $body = @{
            client_id     = $ClientId
            scope         = "https://graph.microsoft.com/.default"
            client_secret = $secretPlain
            grant_type    = "client_credentials"
        }
        return (Invoke-RestMethod -Method Post -Uri $tokenUrl -Body $body -ContentType "application/x-www-form-urlencoded").access_token
    } finally {
        if ($secretPtr -ne [IntPtr]::Zero) { [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($secretPtr) }
        Remove-Variable secretPlain -ErrorAction SilentlyContinue
    }
}

function Get-FolderId {
    param(
        [Parameter(Mandatory=$true)] [string]$MailboxUPN,
        [Parameter(Mandatory=$true)] [string]$FolderName,
        [Parameter(Mandatory=$true)] [hashtable]$Headers
    )
    $baseUrl = "https://graph.microsoft.com/v1.0"
    $encUser = [uri]::EscapeDataString($MailboxUPN)
    $encFilter = [uri]::EscapeDataString("displayName eq '$FolderName'")
    $uri = "$baseUrl/users/$encUser/mailFolders?`$filter=$encFilter&`$select=id,displayName"
    try {
        $response = Invoke-RestMethod -Method Get -Uri $uri -Headers $Headers
        if ($response.value -and $response.value.Count -gt 0) { return $response.value[0].id }
        throw "Folder '$FolderName' not found"
    } catch { throw "Error finding folder '$FolderName': $_" }
}

function Get-EmailCount {
    param(
        [Parameter(Mandatory=$true)] [string]$MailboxUPN,
        [Parameter(Mandatory=$true)] [string]$FolderId,
        [Parameter(Mandatory=$true)] [datetime]$Date,
        [Parameter(Mandatory=$true)] [hashtable]$Headers
    )
    $baseUrl = "https://graph.microsoft.com/v1.0"
    $encUser = [uri]::EscapeDataString($MailboxUPN)

    $startDate = $Date.Date.ToString("yyyy-MM-ddTHH:mm:ssZ")
    $endDate   = $Date.Date.AddDays(1).ToString("yyyy-MM-ddTHH:mm:ssZ")

    $filter = "receivedDateTime ge $startDate and receivedDateTime lt $endDate"
    $encFilter = [uri]::EscapeDataString($filter)
    $uri = "$baseUrl/users/$encUser/mailFolders/$FolderId/messages?`$filter=$encFilter&`$count=true&`$top=1&`$select=id"

    $Headers["ConsistencyLevel"] = "eventual"
    try {
        $response = Invoke-RestMethod -Method Get -Uri $uri -Headers $Headers
        return $response.'@odata.count'
    } catch {
        Write-Host "Error getting email count: $_" -ForegroundColor Red
        return 0
    }
}

function Get-EmailDetails {
    param(
        [Parameter(Mandatory=$true)] [string]$MailboxUPN,
        [Parameter(Mandatory=$true)] [string]$FolderId,
        [Parameter(Mandatory=$true)] [datetime]$Date,
        [Parameter(Mandatory=$true)] [hashtable]$Headers,
        [int]$TopCount = 1000
    )
    $baseUrl = "https://graph.microsoft.com/v1.0"
    $encUser = [uri]::EscapeDataString($MailboxUPN)

    $startDate = $Date.Date.ToString("yyyy-MM-ddTHH:mm:ssZ")
    $endDate   = $Date.Date.AddDays(1).ToString("yyyy-MM-ddTHH:mm:ssZ")

    $filter = "receivedDateTime ge $startDate and receivedDateTime lt $endDate"
    $encFilter = [uri]::EscapeDataString($filter)
    # Include To/Cc/Bcc for downstream filtering
    $encSelect = [uri]::EscapeDataString("subject,from,toRecipients,ccRecipients,bccRecipients,receivedDateTime,internetMessageId,conversationId")

    # Sort ascending (oldest -> newest) for stable display; change to 'desc' if you prefer latest first
    $uri = "$baseUrl/users/$encUser/mailFolders/$FolderId/messages?`$filter=$encFilter&`$top=$TopCount&`$select=$encSelect&`$orderby=receivedDateTime asc"

    $allEmails = @()
    $nextLink = $uri
    try {
        while ($nextLink) {
            $response = Invoke-RestMethod -Method Get -Uri $nextLink -Headers $Headers
            if ($response.value) { $allEmails += $response.value }
            $nextLink = $response.'@odata.nextLink'
            if ($allEmails.Count -gt 10000) {
                Write-Host "Warning: Retrieved over 10,000 emails. Stopping pagination." -ForegroundColor Yellow
                break
            }
        }
        return $allEmails
    } catch {
        Write-Host "Error getting email details: $_" -ForegroundColor Red
        return @()
    }
}

function Get-HourlyBreakdown {
    param(
        [Parameter(Mandatory=$true)] [array]$Emails,
        [Parameter(Mandatory=$true)] [datetime]$Date
    )
    Write-Host "`n=== HOURLY BREAKDOWN ===" -ForegroundColor Green
    Write-Host "Date: $($Date.ToString('yyyy-MM-dd'))" -ForegroundColor White
    Write-Host "Time zone: UTC (adjust for your local time zone if needed)" -ForegroundColor Yellow
    Write-Host ""

    $hourlyGroups = $Emails | Group-Object { [datetime]::Parse($_.receivedDateTime).Hour } | Sort-Object Name

    $totalEmails = 0
    $hourlyData = @()
    for ($hour = 0; $hour -lt 24; $hour++) {
        $hourGroup = $hourlyGroups | Where-Object { $_.Name -eq $hour }
        $count = if ($hourGroup) { $hourGroup.Count } else { 0 }
        $totalEmails += $count
        $hourlyData += [PSCustomObject]@{
            Hour       = $hour
            TimeRange  = ("{0:00}:00 - {0:00}:59" -f $hour)
            Count      = $count
            Percentage = 0
        }
    }
    foreach ($data in $hourlyData) {
        if ($totalEmails -gt 0) { $data.Percentage = [math]::Round(($data.Count / $totalEmails) * 100, 1) }
    }

    Write-Host "Hour Range        | Count | Percentage" -ForegroundColor Cyan
    Write-Host "------------------|-------|------------" -ForegroundColor Cyan
    foreach ($data in $hourlyData) {
        $color = if ($data.Count -gt 0) { if ($data.Count -gt ($totalEmails * 0.1)) { "Yellow" } else { "White" } } else { "DarkGray" }
        Write-Host ("{0} | {1,5} | {2,8}%" -f $data.TimeRange, $data.Count, $data.Percentage) -ForegroundColor $color
    }
    Write-Host "------------------|-------|------------" -ForegroundColor Cyan
    Write-Host ("Total             | {0,5} |" -f $totalEmails) -ForegroundColor Green

    $peakHours = $hourlyData | Where-Object { $_.Count -gt 0 } | Sort-Object Count -Descending | Select-Object -First 3
    if ($peakHours) {
        Write-Host "`nPeak Hours:" -ForegroundColor Green
        foreach ($peak in $peakHours) {
            Write-Host ("  {0}: {1} emails ({2}%)" -f $peak.TimeRange, $peak.Count, $peak.Percentage) -ForegroundColor Yellow
        }
    }
    return $hourlyData
}

# Utility: case-insensitive recipient membership check
function Test-RecipientContains {
    param(
        [Parameter(Mandatory=$true)] [array]$Recipients,
        [Parameter(Mandatory=$true)] [string]$Address
    )
    if (-not $Recipients -or -not $Address) { return $false }
    foreach ($r in $Recipients) {
        if ($r.emailAddress -and $r.emailAddress.address -and ($r.emailAddress.address -ieq $Address)) { return $true }
    }
    return $false
}

# Sent Items cache & ACK finder (simple: same-day, after receipt, To-only, no Cc/Bcc)
function Get-SentEmailsForDate {
    param(
        [Parameter(Mandatory=$true)] [string]$MailboxUPN,
        [Parameter(Mandatory=$true)] [datetime]$Date,
        [Parameter(Mandatory=$true)] [hashtable]$Headers,
        [int]$PageTop = 999
    )
    $baseUrl = "https://graph.microsoft.com/v1.0"
    $encUser = [uri]::EscapeDataString($MailboxUPN)

    $startDate = $Date.Date.ToString("yyyy-MM-ddTHH:mm:ssZ")
    $endDate   = $Date.Date.AddDays(1).ToString("yyyy-MM-ddTHH:mm:ssZ")

    $filter = "sentDateTime ge $startDate and sentDateTime lt $endDate"
    $encFilter = [uri]::EscapeDataString($filter)
    $encSelect = [uri]::EscapeDataString("id,subject,sentDateTime,from,toRecipients,ccRecipients,bccRecipients")

    $uri = "$baseUrl/users/$encUser/mailFolders('sentitems')/messages?`$filter=$encFilter&`$orderby=sentDateTime asc&`$top=$PageTop&`$select=$encSelect"

    $allSent = @()
    $nextLink = $uri
    try {
        while ($nextLink) {
            $resp = Invoke-RestMethod -Method Get -Uri $nextLink -Headers $Headers
            if ($resp.value) { $allSent += $resp.value }
            $nextLink = $resp.'@odata.nextLink'
            if ($allSent.Count -gt 20000) {
                Write-Host "Warning: Retrieved over 20,000 sent messages. Stopping pagination." -ForegroundColor Yellow
                break
            }
        }
        return $allSent
    } catch {
        Write-Host "Error getting sent emails: $_" -ForegroundColor Red
        return @()
    }
}

function Find-AckForInboundSameDay {
    param(
        [Parameter(Mandatory=$true)] [object]$InboundEmail,  # one of $allEmails (inbox_copy)
        [Parameter(Mandatory=$true)] [array]$SentCache       # list from Get-SentEmailsForDate()
    )
    if (-not $InboundEmail.from -or -not $InboundEmail.from.emailAddress) {
        return [PSCustomObject]@{ Acknowledged = $false; Message = $null }
    }
    $senderEmail = $InboundEmail.from.emailAddress.address
    if (-not $senderEmail) {
        return [PSCustomObject]@{ Acknowledged = $false; Message = $null }
    }

    $receivedUtc = [datetime]::Parse($InboundEmail.receivedDateTime).ToUniversalTime()
    $endOfDayUtc = (Get-Date ($receivedUtc.ToString("yyyy-MM-ddT00:00:00Z"))).AddDays(1)

    $candidates = $SentCache | Where-Object {
        $st = [datetime]::Parse($_.sentDateTime).ToUniversalTime()
        $st -ge $receivedUtc -and $st -lt $endOfDayUtc
    } | Where-Object {
        (Test-RecipientContains -Recipients $_.toRecipients -Address $senderEmail) -and
        (-not $_.ccRecipients -or $_.ccRecipients.Count -eq 0) -and
        (-not $_.bccRecipients -or $_.bccRecipients.Count -eq 0)
    }

    if ($candidates.Count -gt 0) {
        $pick = $candidates | Sort-Object { [datetime]::Parse($_.sentDateTime) } | Select-Object -First 1
        return [PSCustomObject]@{ Acknowledged = $true; Message = $pick }
    }
    return [PSCustomObject]@{ Acknowledged = $false; Message = $null }
}

# Heuristic: detect replies/forwards by subject
function Test-IsReplySubject {
    param([string]$Subject)
    if ([string]::IsNullOrWhiteSpace($Subject)) { return $false }
    return ($Subject -match '^\s*(RE|FW|FWD)\s*:')
}

# ---- MAIN ----
Write-Host "=== Email Analysis & Ack Checker (inbox_copy) ===" -ForegroundColor Cyan

# Credentials & inputs
$TenantId     = Read-Host "Enter Tenant ID (GUID)"
$ClientId     = Read-Host "Enter Client ID (App ID)"
$ClientSecret = Read-Host "Enter Client Secret" -AsSecureString
$MailboxUPN   = Read-Host "Enter mailbox UPN/email"

$DateInput = Read-Host "Enter date to check (YYYY-MM-DD format, or press Enter for today)"
if ([string]::IsNullOrWhiteSpace($DateInput)) {
    $CheckDate = Get-Date
} else {
    try { $CheckDate = [datetime]::ParseExact($DateInput, "yyyy-MM-dd", $null) }
    catch { Write-Host "Invalid date format. Using today's date." -ForegroundColor Yellow; $CheckDate = Get-Date }
}

$ShowDetails         = Read-Host "Show email details? (Y/N, default: N)"
$ShowHourlyBreakdown = Read-Host "Show hourly breakdown? (Y/N, default: Y)"
if ([string]::IsNullOrWhiteSpace($ShowHourlyBreakdown)) { $ShowHourlyBreakdown = "Y" }

# Address to treat as "me" for To-only inbound view (defaults to mailbox UPN)
$PrimaryRecipient = Read-Host "Treat which address as 'me' for To-only inbound filter? (default: $MailboxUPN)"
if ([string]::IsNullOrWhiteSpace($PrimaryRecipient)) { $PrimaryRecipient = $MailboxUPN }

# Ack check toggle
$CheckAcks = Read-Host "Check for acknowledgements? (Y/N, default: Y)"
if ([string]::IsNullOrWhiteSpace($CheckAcks)) { $CheckAcks = "Y" }

Write-Host "`nGetting access token..." -ForegroundColor Cyan
try {
    $token = Get-AccessToken -TenantId $TenantId -ClientId $ClientId -ClientSecret $ClientSecret
    $headers = @{ "Authorization" = "Bearer $token" }

    Write-Host "Finding 'inbox_copy' folder..." -ForegroundColor Cyan
    $folderId = Get-FolderId -MailboxUPN $MailboxUPN -FolderName "inbox_copy" -Headers $headers

    Write-Host "Counting emails for $($CheckDate.ToString('yyyy-MM-dd'))..." -ForegroundColor Cyan
    $emailCount = Get-EmailCount -MailboxUPN $MailboxUPN -FolderId $folderId -Date $CheckDate -Headers $headers

    Write-Host "`n=== DAILY SUMMARY ===" -ForegroundColor Green
    Write-Host "Date:    $($CheckDate.ToString('yyyy-MM-dd'))" -ForegroundColor White
    Write-Host "Mailbox: $MailboxUPN" -ForegroundColor White
    Write-Host "Folder:  inbox_copy" -ForegroundColor White
    Write-Host "Total emails received: $emailCount" -ForegroundColor Yellow

    $allEmails = @()

    # Load emails for hourly + filtering + details (if there are any)
    if ($emailCount -gt 0) {
        Write-Host "`nRetrieving all emails for the date..." -ForegroundColor Cyan
        $allEmails = Get-EmailDetails -MailboxUPN $MailboxUPN -FolderId $folderId -Date $CheckDate -Headers $headers

        if ($ShowHourlyBreakdown -match '^[Yy]') {
            if ($allEmails.Count -gt 0) {
                [void](Get-HourlyBreakdown -Emails $allEmails -Date $CheckDate)
            } else {
                Write-Host "No emails found for detailed analysis." -ForegroundColor Yellow
            }
        }
    }

    # Build To-any and To-only inbound views for $PrimaryRecipient
    $emailsToOnly = @()
    $emailsToAlsoCcOrBcc = @()
    $emailsToAny = @()
    if ($allEmails -and $allEmails.Count -gt 0) {
        $emailsToAny = $allEmails | Where-Object {
            Test-RecipientContains -Recipients $_.toRecipients -Address $PrimaryRecipient
        }
        $emailsToOnly = $allEmails | Where-Object {
            (Test-RecipientContains -Recipients $_.toRecipients -Address $PrimaryRecipient) -and
            (-not $_.ccRecipients -or $_.ccRecipients.Count -eq 0) -and
            (-not $_.bccRecipients -or $_.bccRecipients.Count -eq 0)
        }
        $emailsToAlsoCcOrBcc = $allEmails | Where-Object {
            (Test-RecipientContains -Recipients $_.toRecipients -Address $PrimaryRecipient) -and
            ( ($_.ccRecipients -and $_.ccRecipients.Count -gt 0) -or ($_.bccRecipients -and $_.bccRecipients.Count -gt 0) )
        }

        Write-Host ("To-any for {0}: {1}" -f $PrimaryRecipient, $emailsToAny.Count) -ForegroundColor Yellow
        Write-Host ("  …of which To-only (no CC/BCC): {0}" -f $emailsToOnly.Count) -ForegroundColor Yellow
        Write-Host ("To (with CC/BCC present) for {0}: {1}" -f $PrimaryRecipient, $emailsToAlsoCcOrBcc.Count) -ForegroundColor White
    }

    # DETAILS + ACK (most recent 50)
    $sentCache = @()
    if ($ShowDetails -match '^[Yy]' -and $allEmails -and $allEmails.Count -gt 0) {

        # Cache Sent Items once for the day if checking ACKs
        if ($CheckAcks -match '^[Yy]') {
            Write-Host "`nRetrieving all Sent Items for the date..." -ForegroundColor Cyan
            $sentCache = Get-SentEmailsForDate -MailboxUPN $MailboxUPN -Date $CheckDate -Headers $headers
            Write-Host ("Found {0} sent emails on {1}." -f $sentCache.Count, $CheckDate.ToString('yyyy-MM-dd')) -ForegroundColor White
        }

        Write-Host "`n=== EMAIL DETAILS (Most Recent 50) ===" -ForegroundColor Green
        $recentEmails = $allEmails | Sort-Object { [datetime]::Parse($_.receivedDateTime) } -Descending | Select-Object -First 50

        $ackYes = 0; $ackNo = 0
        foreach ($email in $recentEmails) {
            $receivedLocal = [datetime]::Parse($email.receivedDateTime).ToString("HH:mm:ss")

            # From
            $fromEmail = $null
            $fromLine = "<unknown>"
            if ($email.from -and $email.from.emailAddress) {
                $fn = $email.from.emailAddress.name
                $fe = $email.from.emailAddress.address
                $fromEmail = $fe
                $fromLine = if ($fn) { "$fn <$fe>" } else { "$fe" }
            }

            # To (inbound)
            $toList = @()
            if ($email.toRecipients) {
                $toList = $email.toRecipients | ForEach-Object {
                    if ($_.emailAddress) {
                        $n = $_.emailAddress.name
                        $a = $_.emailAddress.address
                        if ($n) { "$n <$a>" } else { "$a" }
                    }
                }
            }
            $toJoined = if ($toList.Count -gt 0) { ($toList -join '; ') } else { "<none>" }

            Write-Host "[$receivedLocal] From: $fromLine" -ForegroundColor Cyan
            Write-Host "            To:   $toJoined" -ForegroundColor Cyan
            Write-Host "    Subject: $($email.subject)" -ForegroundColor White

            if ($CheckAcks -match '^[Yy]') {
                if ($fromEmail -and $sentCache -and $sentCache.Count -gt 0) {
                    $ack = Find-AckForInboundSameDay -InboundEmail $email -SentCache $sentCache
                    if ($ack.Acknowledged) {
                        $ackYes++
                        $sentLocal = [datetime]::Parse($ack.Message.sentDateTime).ToString("HH:mm:ss")
                        Write-Host ("    Ack: YES  (sent {0})  Subject: {1}" -f $sentLocal, $ack.Message.subject) -ForegroundColor Green
                    } else {
                        $ackNo++
                        Write-Host "    Ack: NO" -ForegroundColor Yellow
                    }
                } else {
                    $ackNo++
                    Write-Host "    Ack: NO (missing inbound From or empty Sent cache)" -ForegroundColor Yellow
                }
            }
            Write-Host ""
        }

        if ($CheckAcks -match '^[Yy]') {
            Write-Host "=== ACK SUMMARY (Most Recent 50) ===" -ForegroundColor Green
            Write-Host ("Acknowledged: {0}" -f $ackYes) -ForegroundColor Green
            Write-Host ("Not acknowledged: {0}" -f $ackNo) -ForegroundColor Yellow
        }

        # TO-ONLY DETAILS for $PrimaryRecipient (No Cc/Bcc)
        if ($emailsToOnly -and $emailsToOnly.Count -gt 0) {
            Write-Host ("`n=== EMAILS WHERE '{0}' IS IN TO (NO CC/BCC) — Most Recent 50 ===" -f $PrimaryRecipient) -ForegroundColor Green
            $recentToOnly = $emailsToOnly | Sort-Object { [datetime]::Parse($_.receivedDateTime) } -Descending | Select-Object -First 50
            foreach ($email in $recentToOnly) {
                $receivedTime = [datetime]::Parse($email.receivedDateTime).ToString("HH:mm:ss")

                $fromAddr = "<unknown>"; $fromEmail = $null
                if ($email.from -and $email.from.emailAddress) {
                    $fromName = $email.from.emailAddress.name
                    $fromEmail = $email.from.emailAddress.address
                    $fromAddr = if ($fromName) { "$fromName <$fromEmail>" } else { "$fromEmail" }
                }

                $toList2 = @()
                if ($email.toRecipients) {
                    $toList2 = $email.toRecipients | ForEach-Object {
                        if ($_.emailAddress) {
                            $n = $_.emailAddress.name
                            $a = $_.emailAddress.address
                            if ($n) { "$n <$a>" } else { "$a" }
                        }
                    }
                }
                $toJoined2 = if ($toList2.Count -gt 0) { ($toList2 -join '; ') } else { "<none>" }

                Write-Host "[$receivedTime] From: $fromAddr" -ForegroundColor Cyan
                Write-Host "            To:   $toJoined2" -ForegroundColor Cyan
                Write-Host "    Subject: $($email.subject)" -ForegroundColor White

                if ($CheckAcks -match '^[Yy]' -and $fromEmail -and $sentCache -and $sentCache.Count -gt 0) {
                    $ack = Find-AckForInboundSameDay -InboundEmail $email -SentCache $sentCache
                    if ($ack.Acknowledged) {
                        $sentLocal = [datetime]::Parse($ack.Message.sentDateTime).ToString("HH:mm:ss")
                        Write-Host ("    Ack: YES  (sent {0})  Subject: {1}" -f $sentLocal, $ack.Message.subject) -ForegroundColor Green
                    } else {
                        Write-Host "    Ack: NO" -ForegroundColor Yellow
                    }
                }
                Write-Host ""
            }
        } else {
            Write-Host ("`n=== No emails where '{0}' is TO-only (no CC/BCC) ===" -f $PrimaryRecipient) -ForegroundColor DarkGray
        }
    }

    # Ensure sent cache is available for final ACK totals even when ShowDetails = N
    if ($CheckAcks -match '^[Yy]' -and $allEmails -and $allEmails.Count -gt 0 -and (-not $sentCache -or $sentCache.Count -eq 0)) {
        Write-Host "`nRetrieving all Sent Items for the date (for ACK totals)..." -ForegroundColor Cyan
        $sentCache = Get-SentEmailsForDate -MailboxUPN $MailboxUPN -Date $CheckDate -Headers $headers
    }

    # -------- FINAL TOTALS --------
    if ($allEmails -and $allEmails.Count -gt 0) {
        $totalEmails = $allEmails.Count

        $toAnyForPrimary  = $emailsToAny
        $toAnyCount       = $toAnyForPrimary.Count
        $toOnlyCount      = $emailsToOnly.Count

        # ACK totals across ALL inbound emails (same-day; To-only, no Cc/Bcc)
        $ackTotalYes = 0
        $ackTotalNo  = 0
        if ($CheckAcks -match '^[Yy]' -and $sentCache -and $sentCache.Count -gt 0) {
            foreach ($em in $allEmails) {
                $ack = Find-AckForInboundSameDay -InboundEmail $em -SentCache $sentCache
                if ($ack.Acknowledged) { $ackTotalYes++ } else { $ackTotalNo++ }
            }
        }

        # Original vs Reply (heuristic by subject)
        $replyCountAll      = ($allEmails | Where-Object { Test-IsReplySubject -Subject $_.subject }).Count
        $originalCountAll   = $totalEmails - $replyCountAll
        $replyCountToAny    = ($toAnyForPrimary | Where-Object { Test-IsReplySubject -Subject $_.subject }).Count
        $originalCountToAny = $toAnyCount - $replyCountToAny

        Write-Host "`n=== FINAL TOTALS ===" -ForegroundColor Green
        Write-Host ("Total emails: {0}" -f $totalEmails) -ForegroundColor Yellow
        Write-Host ("Total with '{0}' in To (any): {1}" -f $PrimaryRecipient, $toAnyCount) -ForegroundColor Yellow
        Write-Host ("  …of which To-only (no CC/BCC): {0}" -f $toOnlyCount) -ForegroundColor Yellow

        if ($CheckAcks -match '^[Yy]') {
            Write-Host ("Acknowledged (same-day To-only reply found): {0}" -f $ackTotalYes) -ForegroundColor Green
            Write-Host ("Not acknowledged: {0}" -f $ackTotalNo) -ForegroundColor Yellow
        }

        Write-Host "`nOriginal vs Reply (by subject)" -ForegroundColor Cyan
        Write-Host ("ALL inbound:     Original={0}  Reply={1}" -f $originalCountAll, $replyCountAll) -ForegroundColor White
        Write-Host ("To-any for '{0}': Original={1}  Reply={2}" -f $PrimaryRecipient, $originalCountToAny, $replyCountToAny) -ForegroundColor White
    } else {
        Write-Host "`n=== FINAL TOTALS ===" -ForegroundColor Green
        Write-Host "No emails found for this date." -ForegroundColor Yellow
    }

    Write-Host "`n=== ANALYSIS COMPLETE ===" -ForegroundColor Green
    Write-Host "All operations are read-only (Mail.Read). Times shown are UTC." -ForegroundColor Yellow

} catch {
    Write-Host "Error: $_" -ForegroundColor Red
}
